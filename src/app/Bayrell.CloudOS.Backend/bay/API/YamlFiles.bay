/*!
 *  Bayrell Cloud OS
 *
 *  (c) Copyright 2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Bayrell.CloudOS.Backend.API;

use Runtime.rtl;
use Runtime.lib;
use Runtime.fs;
use Runtime.Exceptions.ApiException;
use Runtime.Exceptions.FileNotFound;
use Runtime.Core.RemoteCallAnswer;
use Runtime.Core.RemoteCallRequest;
use Runtime.Backend.ApiList;
use Runtime.Backend.ApiMethod;
use Runtime.Backend.ApiMiddleware;
use Runtime.Web.ORM.QueryBuilder;
use Bayrell.CloudOS.Backend.DockerLib;


@ApiList{ "object_name": "Bayrell.CloudOS.YamlFiles", "interface_name": "default" }
static class YamlFiles
{
	
	/**
	 * Get files
	 */
	@ApiMethod{ "method_name": "getFiles" }
	static async list getFilesAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		Collection<Dict> arr =
			await fs::readDir("/data/config")
			|> .filter( lib::and([ lib::equalNot("."), lib::equalNot("..") ]) )
			|> .map
			(
				Dict (string stack_name) =>
					new Dict
					{
						"name": stack_name
						"files": [],
					}
			)
		;
		
		Vector<Dict> stacks = new Vector();
		for (int i=0; i<arr.count(); i++)
		{
			Dict stack = arr[i];
			if (not await fs::isDir(stack["name"], "/data/config/"))
			{
				continue;
			}
			stack <= files <=
				await fs::readDir(stack["name"], "/data/config/")
				|> .filter( lib::and([ lib::equalNot("."), lib::equalNot("..") ]) )
			;
			stacks.pushValue(stack);
		}
		
		answer = answer::success(answer, stacks.toCollection());
		
		return [ request, answer ];
	}
	
	
	
	/**
	 * Open file
	 */
	@ApiMethod{ "method_name": "openFile" }
	static async list openFileAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		string stack_name = request.data["stack_name"] |> default string "";
		string file_name = request.data["file_name"] |> default string "";
		string file_path = fs::concat(stack_name, file_name);
		
		/* Check file exists */
		bool exists = await fs::exists(file_path, "/data/config");
		if (not exists)
		{
			throw new FileNotFound(file_path);
		}
		
		/* Read file */
		string content = await fs::readFile(file_path, "/data/config");
		
		/* Answer */
		answer = answer::success
		(
			answer,
			{
				"stack_name": stack_name,
				"file_name": file_name,
				"file_path": file_path,
				"content": content,
			}
		);
		
		return [ request, answer ];
	}
	
	
	
	/**
	 * Save file
	 */
	@ApiMethod{ "method_name": "saveFile" }
	static async list saveFileAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		string stack_name = request.data["stack_name"] |> default string "";
		string file_name = request.data["file_name"] |> default string "";
		string content = request.data["content"] |> default string "";
		string file_path = fs::concat(stack_name, file_name);
		
		/* Make dir */
		await fs::mkdir(rs::dirname(file_path), "/data/config", "777");
		
		/* Save file */
		await fs::saveFile(file_path, content, "/data/config");
		
		/* Answer */
		answer = answer::success
		(
			answer,
			{
				"stack_name": stack_name,
				"file_name": file_name,
				"file_path": file_path,
			}
		);
		
		return [ request, answer ];
	}
	
	
	
	/**
	 * Create file
	 */
	@ApiMethod{ "method_name": "createFile" }
	static async list createFileAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		string stack_name = request.data["stack_name"] |> default string "";
		string file_name = request.data["file_name"] |> default string "";
		string file_path = fs::concat(stack_name, file_name);
		
		/* Check file exists */
		bool exists = await fs::exists(file_path, "/data/config");
		if (exists)
		{
			/* Answer */
			answer = answer::success
			(
				answer,
				{
					"stack_name": stack_name,
					"file_name": file_name,
					"file_path": file_path,
				}
			);
			
			return [ request, answer ];
		}
		
		/* Make dir */
		await fs::mkdir(rs::dirname(file_path), "/data/config", "0777");
		
		/* Save file */
		await fs::saveFile(file_path, "", "/data/config");
		
		/* Answer */
		answer = answer::success
		(
			answer,
			{
				"stack_name": stack_name,
				"file_name": file_name,
				"file_path": file_path,
			}
		);
		
		return [ request, answer ];
	}
	
	
	
	/**
	 * Rename file
	 */
	@ApiMethod{ "method_name": "renameFile" }
	static async list renameFileAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		string stack_name = request.data["stack_name"] |> default string "";
		string file_name = request.data["file_name"] |> default string "";
		string file_name_new = request.data["file_name_new"] |> default string "";
		string file_path = fs::concat(stack_name, file_name);
		string file_path_new = fs::concat(stack_name, file_name_new);
		
		/* Check file exists */
		bool exists = await fs::exists(file_path, "/data/config");
		if (not exists)
		{
			throw new FileNotFound(file_path);
		}
		
		/* Rename file */
		await fs::renameFile(file_path, file_path_new, "/data/config");
		
		/* Answer */
		answer = answer::success
		(
			answer,
			{
				"stack_name": stack_name,
				"file_name": file_name_new,
				"file_path": file_path_new,
			}
		);
		
		return [ request, answer ];
	}
	
	
	
	/**
	 * Delete file
	 */
	@ApiMethod{ "method_name": "deleteFile" }
	static async list deleteFileAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		string stack_name = request.data["stack_name"] |> default string "";
		string file_name = request.data["file_name"] |> default string "";
		string file_path = fs::concat(stack_name, file_name);
		
		/* Check file exists */
		bool exists = await fs::exists(file_path, "/data/config");
		if (not exists)
		{
			throw new FileNotFound(file_path);
		}
		
		/* Delete file */
		await fs::unlink(file_path, "/data/config");
		
		/* Answer */
		answer = answer::success
		(
			answer,
			{
				"stack_name": stack_name,
				"file_name": file_name,
				"file_path": file_path,
			}
		);
		
		return [ request, answer ];
	}
	
	
	
	/**
	 * Rename stack
	 */
	@ApiMethod{ "method_name": "editStack" }
	static async list editStackAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		string stack_name = request.data["stack_name"] |> default string "";
		string stack_name_new = request.data["stack_name_new"] |> default string "";
		
		/* Check file exists */
		bool exists = await fs::exists(stack_name, "/data/config");
		if (not exists)
		{
			throw new FileNotFound(stack_name);
		}
		
		/* Rename file */
		await fs::renameFile(stack_name, stack_name_new, "/data/config");
		
		/* Answer */
		answer = answer::success
		(
			answer,
			{
				"stack_name": stack_name_new,
			}
		);
		
		return [ request, answer ];
	}
	
	
	
	/**
	 * Delete stack
	 */
	@ApiMethod{ "method_name": "deleteStack" }
	static async list deleteStackAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		string stack_name = request.data["stack_name"] |> default string "";
		
		/* Check file exists */
		bool exists = await fs::exists(stack_name, "/data/config");
		if (not exists)
		{
			throw new FileNotFound(stack_name);
		}
		
		Collection<string> arr = await fs::readDir(stack_name, "/data/config")
			|> .filter( lib::and([ lib::equalNot("."), lib::equalNot("..") ]) )
		;
		if (arr.count() > 0)
		{
			throw new ApiException("Stack does not empty");
		}
		
		/* Delete file */
		await fs::unlink(stack_name, "/data/config");
		
		/* Answer */
		answer = answer::success
		(
			answer,
			{
				"stack_name": stack_name,
			}
		);
		
		return [ request, answer ];
	}
	
	
	
	/**
	 * Compose
	 */
	@ApiMethod{ "method_name": "compose" }
	static async list composeAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		string stack_name = request.data["stack_name"] |> default string "";
		string file_name = request.data["file_name"] |> default string "";
		string file_path = fs::concat(stack_name, file_name);
		string ext_name = rs::extname(file_name);
		
		if (ext_name != "yaml")
		{
			throw new ApiException("File must have yaml extension");
		}
		
		string yaml_file_path = fs::concat("/data/config", file_path);
		string cmd = "sudo docker stack deploy -c " ~ yaml_file_path ~ " " ~ stack_name ~ " --with-registry-auth";
		string result = await DockerLib::exec(cmd ~ " 2>/dev/null");
		
		/* Answer */
		answer = answer::success
		(
			answer,
			{
				"stack_name": stack_name,
				"file_name": file_name,
				"file_path": file_path,
			},
			result
		);
		
		return [ request, answer ];
	}
	
}