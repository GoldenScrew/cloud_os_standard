/*!
 *  Bayrell Cloud OS
 *
 *  (c) Copyright 2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Bayrell.CloudOS.Backend.ORM;

use Runtime.Core.ApiException;
use Runtime.ORM.Annotations.AutoIncrement;
use Runtime.ORM.Annotations.BigIntType;
use Runtime.ORM.Annotations.BooleanType;
use Runtime.ORM.Annotations.ForeignKey;
use Runtime.ORM.Annotations.Index;
use Runtime.ORM.Annotations.JsonType;
use Runtime.ORM.Annotations.Primary;
use Runtime.ORM.Annotations.StringType;
use Runtime.ORM.Annotations.Unique;
use Runtime.ORM.Annotations.Virtual;
use Runtime.ORM.ConnectionInterface as Connection;
use Runtime.ORM.CursorInterface as Cursor;
use Runtime.ORM.DriverInterface as ORMDriver;
use Runtime.ORM.Record;
use Bayrell.CloudOS.Backend.DockerLib;
use Bayrell.CloudOS.Backend.DockerTasks;


struct DockerService extends Record
{
	@AutoIncrement{}
	@BigIntType{}
	int service_id;
	
	@StringType{ "length": 100, "nullable": true }
	string docker_service_id;
	
	@StringType{ "length": 1024 }
	string _name;
	
	@StringType{ "length": 1024 }
	string _image;
	
	@BooleanType{}
	bool manual;
	
	@BooleanType{}
	bool enable;
	
	@BigIntType{}
	int timestamp;
	
	@BooleanType{}
	bool is_deleted;
	
	@JsonType{ "nullable": true }
	Dict json;
	
	@JsonType{ "nullable": true }
	Dict tasks;
	
	@JsonType{ "nullable": true }
	Dict balancer;
	
	
	/**
	 * Returns table name
	 */
	pure string table_name() => "docker_services";
	
	
	/**
	 * Keys
	 */
	pure Collection keys() =>
	[
		new Primary
		{
			"keys": ["service_id"],
		},
		new Unique
		{
			"keys": ["docker_service_id"],
		},
		new Index
		{
			"keys": ["is_deleted"],
		}
	];
	
	
	
	
	
	/**
	 * Get diff from spec
	 */
	pure Dict dockerDiffSpec(Dict old_json, Dict new_json)
	{
		if (old_json === null) return null;
		if (new_json === null) return null;
		
		bool updated = false;
		Dict diff_spec = old_json["Spec"] |> default Dict {};
		
		/* Change image */
		string old_image = old_json["Spec", "TaskTemplate", "ContainerSpec", "Image"] |> default string "";
		string new_image = new_json["Spec", "TaskTemplate", "ContainerSpec", "Image"] |> default string "";
		if (old_image != new_image and new_image != "")
		{
			if (rtl::attr(diff_spec, ["TaskTemplate"], null) === null)
			{
				diff_spec = rtl::setAttr(diff_spec, ["TaskTemplate"], {});
			}
			if (rtl::attr(diff_spec, ["TaskTemplate", "ContainerSpec"], null) === null)
			{
				diff_spec = rtl::setAttr(diff_spec, ["TaskTemplate", "ContainerSpec"], {});
			}
			diff_spec = rtl::setAttr(diff_spec, ["TaskTemplate", "ContainerSpec", "Image"], new_image);
			updated = true;
		}
		
		if (updated) return diff_spec;
		return null;
	}
	
	
	
	/**
	 * Add docker service
	 */
	async string dockerAddService(Dict json)
	{
		string s = rtl::json_encode(json["Spec"]);
		string url_api = "/services/create";
		string content = await DockerLib::dockerApi(url_api, "POST", s);
		Dict res = rtl::json_decode(content);
		if (res == null) throw new ApiException( _("Bayrell.CloudOS", "Error create service in docker"), -1 );
		
		string message = res["message"] |> default string _("Bayrell.CloudOS", "Service does not created");
		string docker_service_id = res["ID"];
		if (docker_service_id == null) throw new ApiException( message, -1 );
		
		/* Update spec of the service */
		Dict new_json = await DockerLib::getService(docker_service_id);
		await static::updateServiceInDatabase("", new_json);
		
		return docker_service_id;
	}
	
	
	
	/**
	 * Update docker service
	 */
	async string dockerUpdateService(Dict old_json, Dict new_json)
	{
		string docker_service_id = old_json["ID"];
		string version = old_json["Version", "Index"];
		Dict diff_spec = static::dockerDiffSpec(old_json, new_json);
		if (diff_spec == null) return null;
		
		/* Update service */
		string s = rtl::json_encode(diff_spec);
		string url_api = "/services/" ~ docker_service_id ~ "/update?version=" ~ version;
		string content = await DockerLib::dockerApi(url_api, "POST", s);
		Dict res = rtl::json_decode(content);
		/*
		if (not rtl::isEmpty(res["message"]))
		{
			throw new ApiException( res["message"], -1 );
		}
		*/
		
		/* Update spec of the service */
		Dict spec = await DockerLib::getService(docker_service_id);
		await this.updateServiceInDatabase(docker_service_id, spec);
		
		return docker_service_id;
	}
	
	
	
	/**
	 * Enable service in docker
	 */
	async Dict dockerEnableService(string old_service_id)
	{
		if (old_service_id == null) throw new ApiException( _("Bayrell.CloudOS", "Service ID is not set"), -1 );
		
		Dict item = await this.getServiceFromDb(old_service_id);
		if (item == null) throw new ApiException( _("Bayrell.CloudOS", "Service not found in database"), -1 );
		
		Dict spec = item["json", "Spec"] |> rtl::json_encode;
		if (spec == null) throw new ApiException( _("Bayrell.CloudOS", "Spec not found"), -1 );
		
		string url_api = "/services/create";
		string content = await DockerLib::dockerApi(url_api, "POST", spec);
		Dict res = rtl::json_decode(content);
		if (res == null) throw new ApiException( _("Bayrell.CloudOS", "Create service error"), -1 );
		
		string new_service_id = res["ID"];
		if (new_service_id == null) throw new ApiException( _("Bayrell.CloudOS", "Service does not created"), -1 );
		
		/* Update spec of the service */
		Dict spec = await DockerLib::getService(new_service_id);
		await this.updateServiceInDatabase(old_service_id, spec);
		
		/* Read service from database */
		Dict item = await this.getServiceFromDb(new_service_id);
		
		return { "Message": _("Bayrell.CloudOS", "Service enabled"), "Code": 1, "item": item };
	}
	
	
	
	/**
	 * Disable service
	 */
	async Dict dockerDisableService(string docker_service_id)
	{
		if (docker_service_id == null) throw new ApiException( _("Bayrell.CloudOS", "Service ID is not set"), -1 );
		
		/* Delete service */
		string url_api = "/services/" ~ docker_service_id;
		string content = await DockerLib::dockerApi(url_api, "DELETE");
		Dict res = rtl::json_decode(content);
		
		/* Success */
		if (content != "")
		{
			/* Check if error */
			string message = res.get("message", "");
			if (message != "")
			{
				throw new ApiException( message, -1 );
			}
			
			throw new ApiException( "Error disable service", -1 );
		}
		
		/* Disables service in database */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		Cursor cursor = await orm.query
		(
			"update services set enable=0 where docker_service_id = :docker_service_id limit 1",
			{
				"docker_service_id": docker_service_id,
			}
		);
		await cursor.close();
		
		Dict item = await this.getServiceFromDb(docker_service_id);
		
		return { "Message": _("Bayrell.CloudOS", "Service disabled"), "Code": 1, "item": item };
	}
	
	
	
	/**
	 * Returns item by service id from database
	 */
	async Dict getServiceFromDb(string docker_service_id)
	{
		string table_name = static::getTableName();
		
		/* Process primary key */
		Dict pk =
		{
			"docker_service_id": docker_service_id,
		};
		pk = this.toDatabase(pk);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.select(table_name, pk, 0, 1);
		Dict item = cursor.fetchOne();
		await cursor.close();
		
		/* From database */
		item = await this.fromDatabase(item);
		
		return item;
	}
	
	
	
	/**
	 * Update service in database
	 */
	static async Dict updateServiceInDatabase(string old_service_id, Dict json)
	{
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		int time = rtl::time();
		string new_service_id = json["ID"] |> default string "";
		string service_name = json["Spec", "Name"] |> default string ""
		string service_image = json["Spec", "TaskTemplate", "ContainerSpec", "Image"] |> default string "";
		
		if (new_service_id == null) throw new ApiException( _("Bayrell.CloudOS", "New service id is not set"), -1 );
		
		/* Update service id */
		if (old_service_id != "")
		{
			Cursor cursor = await orm.query
			(
				"update services set docker_service_id=:new_service_id, is_deleted=0, enable=1 " ~
					" where docker_service_id = :old_service_id limit 1",
				{
					"old_service_id": old_service_id,
					"new_service_id": new_service_id,
				}
			);
			await cursor.close();
		}
		
		if (old_service_id != new_service_id)
		{
			/* Delete wrong service */
			if (old_service_id != "")
			{
				Cursor cursor = await orm.query
				(
					"delete from services " ~
						" where docker_service_id = :old_service_id limit 1",
					{
						"old_service_id": old_service_id,
					}
				);
				await cursor.close();
			}
		}
		
		/* Insert or update */
		await orm.insert_or_update
		(
			"services",
			{
				"docker_service_id": new_service_id,
			},
			{
				"_name": service_name,
				"_image": service_image,
				"is_deleted": 0,
				"enable": 1,
				"timestamp": time,
				"json": rtl::json_encode(json),
			}
		);
		
		return { "Message": _("Bayrell.CloudOS", "Service deleted"), "Code": 1 };
	}
	
}
