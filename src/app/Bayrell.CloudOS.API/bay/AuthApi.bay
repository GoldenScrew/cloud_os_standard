/*!
 *  Bayrell Cloud Web Panel
 *
 *  (c) Copyright 2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace App.User;

use Runtime.lib;
use Runtime.MessageRPC;
use Runtime.RuntimeConstant;
use Runtime.RuntimeUtils;
use Runtime.Exceptions.ApiException;
use Runtime.Crypt.Password;
use Runtime.ORM.Cursor;
use Runtime.ORM.ORMProviderInterface;
use Runtime.Web.Annotations.ApiList;
use Runtime.Web.Annotations.ApiMethod;
use Runtime.Web.Annotations.Route;
use Runtime.Web.Annotations.RouteList;
use Runtime.Web.Cookie;
use Runtime.Web.JsonResponse;
use Runtime.Web.RenderContainer;
use Runtime.Web.Response;
use App.User.AuthToken;


@ApiList{ "api_name": "App.Auth" }
@RouteList{}
class AuthApi
{
	#ifdef BACKEND then
	
	
	/**
	 * Check login and password
	 */
	static async bool checkLoginAndPassword(string username, string password)
	{
		ORMProviderInterface p = @ -> method getProvider(classof ORMProviderInterface);
		
		/* Select password */
		Dict item = p -> await method query
		(
			"select u.*, a.value as password from " ~ p.prefix ~ "docker_users as u " ~
			"left join docker_users_auth as a on (u.id = a.user_id and a.type='password') " ~
			"where u.name=:user_name",
			{
				"user_name": username,
			}
		)
		-> await method getOne;
		
		if (item == null) return false;
		string hash = item.get("password", "");
		return Password::verify(password, hash);
	}
	
	
	
	/**
	 * Login
	 */
	@Route{ "uri": "/api/login/" }
	static async RenderContainer actionLogin(RenderContainer container)
	{
		MessageRPC msg = new MessageRPC{};
		AuthToken token = null;
		
		Dict payload = container
			-> attr "request"
			-> method decodePayload
		;
		
		string username = payload
			-> lib::get("username", "")
			-> monad lib::to("string", "")
		;
		
		string password = payload
			-> lib::get("password", "")
			-> monad lib::to("string", "")
		;
		
		bool flag = await static::checkLoginAndPassword(username, password);
		if (not flag)
		{
			msg = msg -> method fail(null, _("App", "Wrong password")) -> lib::set("have_answer", true);
		}
		else
		{
			string cookie_name = @ -> method config([classof AuthToken, "COOKIE_NAME"]);
			string auth_private_key = @ -> method config([classof AuthToken, "AUTH_PRIVATE_KEY"]);
			int cookie_expire = @ -> method config([classof AuthToken, "EXPIRE"]);
			
			int time = @ -> method time;
			int expire = time + cookie_expire;
			token = new AuthToken
			{
				"created": time,
				"expire": expire,
				"login": username,
			};
			token = token -> method sign(auth_private_key);
			
			container = container
				-> method setCookie
				(
					new Cookie
					{
						"name": cookie_name,
						"value": token.token_str,
						"expire": expire,
						"path": "/",
					}
				)
			;
			
			msg = msg -> method success(null, _("App", "Ok")) -> lib::set("have_answer", true);
		}
		
		container <= response <= new JsonResponse{ "data": msg };
		return container;
	}
	
	
	
	/**
	 * Logout
	 */
	@Route{ "uri": "/api/logout/" }
	static async RenderContainer actionLogout(RenderContainer container)
	{
		MessageRPC msg = new MessageRPC{};
		
		string cookie_name = @ -> method config([classof AuthToken, "COOKIE_NAME"]);
		container = container
			-> method setCookie
			(
				new Cookie
				{
					"name": cookie_name,
					"expire": 0,
					"value": "",
					"path": "/",
				}
			)
		;
		
		msg = msg -> method success(null, _("App", "Ok")) -> lib::set("have_answer", true);
		container <= response <= new JsonResponse{ "data": msg };
		return container;
	}
	
	
	
	/**
	 * Logout
	 */
	@ApiMethod{ "method_name": "install", "space_name": "default" }
	static async MessageRPC actionInstall(MessageRPC msg)
	{
		ORMProviderInterface p = @ -> method getProvider(classof ORMProviderInterface);
		
		/* Select count users */
		Dict item = p -> await method query
		(
			"select count(*) as c from " ~ p.prefix ~ "docker_users as u",
			{
			}
		)
		-> await method getOne;
		
		int count = item["c"];
		if (count > 0)
		{
			throw new ApiException(_("App", "Admins is allready exists"), RuntimeConstant::ERROR_VALIDATION);
		}
		
		string username = msg["data"]["username"];
		string password1 = msg["data"]["password1"];
		string password2 = msg["data"]["password2"];
		
		if (username == "")
		{
			throw new ApiException(_("App", "Username is empty"), RuntimeConstant::ERROR_VALIDATION);
		}
		
		if (password1 == "")
		{
			throw new ApiException(_("App", "Password is empty"), RuntimeConstant::ERROR_VALIDATION);
		}
		
		if (password1 != password2)
		{
			throw new ApiException(_("App", "Passwords mistmatch"), RuntimeConstant::ERROR_VALIDATION);
		}
		
		
		/* Create query */
		int user_id = p
			-> await method insert
			(
				p.prefix ~ "docker_users",
				{
					"name": username,
				}
			)
			-> await method end
		;
		
		/* Insert password */
		p
			/* -> lib::set("log_query", true) */
			-> await method insert_or_update
			(
				p.prefix ~ "docker_users_auth",
				{
					"user_id": user_id,
					"type": "password",
				},
				{
					"value": Password::createHash(password1),
				}
			)
			-> await method end
		;
		
		return msg -> method success(null, _("App", "Ok"));
	}
	
	#endif
}
