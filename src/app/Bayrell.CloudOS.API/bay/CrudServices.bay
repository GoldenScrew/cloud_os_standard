/*!
 *  Bayrell Cloud OS
 *
 *  (c) Copyright 2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Bayrell.CloudOS.API;

use Runtime.rtl;

use Runtime.Core.ApiException;
use Runtime.Core.RemoteCallAnswer;
use Runtime.Core.RemoteCallRequest;
use Runtime.Crypt.Password;
use Runtime.ORM.CursorInterface as Cursor;
use Runtime.ORM.DriverInterface as ORMDriver;
use Runtime.Web.Backend.ApiList;
use Runtime.Web.Backend.ApiMethod;
use Runtime.Web.ORM.QueryBuilder;
use Runtime.Web.CRUD.CrudApi;
use Runtime.Web.CRUD.FieldInfo;
use Bayrell.CloudOS.API.DockerLib;


@ApiList{ "object_name": "Bayrell.CloudOS.Services", "interface_name": "core.crud" }
static class CrudServices extends CrudApi
{
	
	/**
	 * Returns crud table name
	 */
	pure string getTableName() => "services";
	
	
	
	/**
	 * Returns table field value
	 */
	Collection<FieldInfo> settings() =>
	[
		new FieldInfo
		{
			"api_name": "service_id",
			"dbtype": "bigint",
			"auto_increment": true,
			"readonly": true,
			"primary": true,
		},
		new FieldInfo
		{
			"api_name": "docker_service_id",
			"dbtype": "string",
			"readonly": true,
		},
		new FieldInfo
		{
			"api_name": "_name",
			"dbtype": "string",
			"required": true,
		},
		new FieldInfo
		{
			"api_name": "_image",
			"dbtype": "string",
			"required": true,
		},
		new FieldInfo
		{
			"api_name": "enable",
			"dbtype": "int",
			"default": "0",
			"readonly": true,
		},
		new FieldInfo
		{
			"api_name": "json",
			"dbtype": "json",
			"readonly": true,
		},
		new FieldInfo
		{
			"api_name": "tasks",
			"dbtype": "json",
			"readonly": true,
		},
		new FieldInfo
		{
			"api_name": "balancer",
			"dbtype": "json",
			"readonly": true,
		},
	];
	
	
	
	/**
	 * Returns table field value
	 */
	Collection<Collection<string>> getDefaultOrder() =>
	[ 
		["service_id", "desc"]
	];
	
	
	
	/**
	 * Process item from database
	 */
	async Dict fromDatabase(Dict item)
	{
		item <= json <= rtl::json_decode(item["json"]);
		item <= tasks <= rtl::json_decode(item["tasks"]);
		item <= balancer <= rtl::json_decode(item["balancer"]);
		return item;
	}
	
	
	
	/**
	 * Init request
	 */
	async void init()
	{
		await parent::init();
	}
	
	
	
	/**
	 * Validate
	 */
	async bool validate()
	{
		await parent::validate();
		
		if (this.action == "search")
		{
		}
		
		else if (this.action == "add" or this.action == "update")
		{
		}
		
		else if (this.action == "delete")
		{
		}
	}
	
	
	
	/**
	 * Build query
	 */
	QueryBuilder buildSearchQuery()
	{
		QueryBuilder q = parent::buildSearchQuery();
		return q;
	}
	
	
	
	/**
	 * Convert item before save to database
	 */
	async Dict convertItem(Dict item)
	{
		item = await parent::convertItem(item);
		return item;
	}
	
	
	
	/**
	 * Process item before response
	 */
	async Dict processItem(Dict item)
	{
		item = await parent::processItem(item);
		return item;
	}
	
	
	
	/**
	 * Process items
	 */
	async void processItems()
	{
		await parent::processItems();
	}
	
	
	
	/**
	 * Create query
	 */
	async void createQuery()
	{
		/* Convert item */
		Dict item = await this.convertItem(this.item);
		
		string service_name = item["_name"] |> default string "";
		string service_image = item["_image"] |> default string "";
		Dict json =
		{
			"Spec":
			{
				"Name": service_name,
				"TaskTemplate":
				{
					"ContainerSpec":
					{
						"Image": service_image,
					}
				}
			}
		};
		string new_service_id = await static::dockerAddService(json);
		this.new_item = await this.getServiceFromDb(new_service_id);
		this.pk =
		{
			"id": this.new_item["id"],
		};
	}
	
	
	
	/**
	 * Custom update query
	 */
	async void updateQuery()
	{
		string old_image = this.old_item["_image"];
		string new_image = this.item["_image"];
		if (new_image != old_image)
		{
			Dict old_json = this.old_item["json"];
			Dict new_json = old_json;
			new_json = rtl::setAttr(new_json, ["Spec", "TaskTemplate", "ContainerSpec", "Image"], new_image);
			
			/* Docker update */
			string new_service_id = await this.dockerUpdateService(old_json, new_json);
			
			/* Read service from database */
			if (not rtl::isEmpty(new_service_id))
			{
				this.new_item = await this.getServiceFromDb(new_service_id);
			}
			else
			{
				this.new_item = this.old_item;
			}
		}
	}
	
	
	
	/**
	 * After
	 */
	async bool after()
	{
		await parent::after();
		
		/* If is success */
		if (this.isSuccess())
		{
			if (this.action == "delete")
			{
				string service_id_1 = this.old_item["docker_service_id"];
				await this.dockerDisableService(service_id_1);
				
				string service_id_2 = this.old_item["json"]["ID"];
				if (service_id_1 != service_id_2)
				{
					await this.dockerDisableService(service_id_2);
				}
			}
		}
	}
	
	
	
	/**
	 * Search api
	 */
	@ApiMethod{ "method_name": "search" }
	static async list searchAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		return await parent::searchAction(request, answer);
	}
	
	
	
	/**
	 * Create
	 */
	@ApiMethod{ "method_name": "create" }
	static async list createAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		return await parent::createAction(request, answer);
	}
	
	
	
	/**
	 * Update
	 */
	@ApiMethod{ "method_name": "update" }
	static async list updateAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		return await parent::updateAction(request, answer);
	}
	
	
	
	/**
	 * Delete
	 */
	@ApiMethod{ "method_name": "delete" }
	static async list deleteAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		return await parent::deleteAction(request, answer);
	}
	
	
	
	/**
	 * Enable
	 */
	@ApiMethod{ "method_name": "enable" }
	static async list enableAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "enable";
		api.answer = answer;
		api.request = request;
		string docker_service_id = request["data", "docker_service_id"];
		
		/* Disable service */
		Dict res = await api.dockerEnableService(docker_service_id);
		Dict item = await api.processItem(res.item);
		answer = answer::success(answer, { "new_item": res["item"] }, res["Message"]);
		
		return [request, answer];
	}
	
	
	
	/**
	 * Disable
	 */
	@ApiMethod{ "method_name": "disable" }
	static async list disableAction(RemoteCallRequest request, RemoteCallAnswer answer)
	{
		/* Create api */
		CrudApi api = rtl::newInstance(static::getCurrentClassName());
		
		/* Get data from request */
		api.action = "disable";
		api.answer = answer;
		api.request = request;
		string docker_service_id = request["data", "docker_service_id"];
		
		/* Disable service */
		Dict res = await api.dockerDisableService(docker_service_id);
		Dict item = await api.processItem(res.item);
		answer = answer::success(answer, { "new_item": res["item"] }, res["Message"]);
		
		return [request, answer];
	}
	
	
	
	/**
	 * Get diff from spec
	 */
	pure Dict dockerDiffSpec(Dict old_json, Dict new_json)
	{
		if (old_json === null) return null;
		if (new_json === null) return null;
		
		bool updated = false;
		Dict diff_spec = old_json["Spec"] |> default Dict {};
		
		/* Change image */
		string old_image = old_json["Spec", "TaskTemplate", "ContainerSpec", "Image"] |> default string "";
		string new_image = new_json["Spec", "TaskTemplate", "ContainerSpec", "Image"] |> default string "";
		if (old_image != new_image and new_image != "")
		{
			if (rtl::attr(diff_spec, ["TaskTemplate"], null) === null)
			{
				diff_spec = rtl::setAttr(diff_spec, ["TaskTemplate"], {});
			}
			if (rtl::attr(diff_spec, ["TaskTemplate", "ContainerSpec"], null) === null)
			{
				diff_spec = rtl::setAttr(diff_spec, ["TaskTemplate", "ContainerSpec"], {});
			}
			diff_spec = rtl::setAttr(diff_spec, ["TaskTemplate", "ContainerSpec", "Image"], new_image);
			updated = true;
		}
		
		if (updated) return diff_spec;
		return null;
	}
	
	
	
	/**
	 * Add docker service
	 */
	async string dockerAddService(Dict json)
	{
		string s = rtl::json_encode(json["Spec"]);
		string url_api = "/services/create";
		string content = await DockerLib::dockerApi(url_api, "POST", s);
		Dict res = rtl::json_decode(content);
		if (res == null) throw new ApiException( _("Bayrell.CloudOS", "Error create service in docker"), -1 );
		
		string message = res["message"] |> default string _("Bayrell.CloudOS", "Service does not created");
		string docker_service_id = res["ID"];
		if (docker_service_id == null) throw new ApiException( message, -1 );
		
		/* Update spec of the service */
		Dict new_json = await DockerLib::getService(docker_service_id);
		await static::updateServiceInDatabase("", new_json);
		
		return docker_service_id;
	}
	
	
	
	/**
	 * Update docker service
	 */
	async string dockerUpdateService(Dict old_json, Dict new_json)
	{
		string docker_service_id = old_json["ID"];
		string version = old_json["Version", "Index"];
		Dict diff_spec = static::dockerDiffSpec(old_json, new_json);
		if (diff_spec == null) return null;
		
		/* Update service */
		string s = rtl::json_encode(diff_spec);
		string url_api = "/services/" ~ docker_service_id ~ "/update?version=" ~ version;
		string content = await DockerLib::dockerApi(url_api, "POST", s);
		Dict res = rtl::json_decode(content);
		/*
		if (not rtl::isEmpty(res["message"]))
		{
			throw new ApiException( res["message"], -1 );
		}
		*/
		
		/* Update spec of the service */
		Dict spec = await DockerLib::getService(docker_service_id);
		await this.updateServiceInDatabase(docker_service_id, spec);
		
		return docker_service_id;
	}
	
	
	
	/**
	 * Enable service in docker
	 */
	async Dict dockerEnableService(string old_service_id)
	{
		if (old_service_id == null) throw new ApiException( _("Bayrell.CloudOS", "Service ID is not set"), -1 );
		
		Dict item = await this.getServiceFromDb(old_service_id);
		if (item == null) throw new ApiException( _("Bayrell.CloudOS", "Service not found in database"), -1 );
		
		Dict spec = item["json", "Spec"] |> rtl::json_encode;
		if (spec == null) throw new ApiException( _("Bayrell.CloudOS", "Spec not found"), -1 );
		
		string url_api = "/services/create";
		string content = await DockerLib::dockerApi(url_api, "POST", spec);
		Dict res = rtl::json_decode(content);
		if (res == null) throw new ApiException( _("Bayrell.CloudOS", "Create service error"), -1 );
		
		string new_service_id = res["ID"];
		if (new_service_id == null) throw new ApiException( _("Bayrell.CloudOS", "Service does not created"), -1 );
		
		/* Update spec of the service */
		Dict spec = await DockerLib::getService(new_service_id);
		await this.updateServiceInDatabase(old_service_id, spec);
		
		/* Read service from database */
		Dict item = await this.getServiceFromDb(new_service_id);
		
		return { "Message": _("Bayrell.CloudOS", "Service enabled"), "Code": 1, "item": item };
	}
	
	
	
	/**
	 * Disable service
	 */
	async Dict dockerDisableService(string docker_service_id)
	{
		if (docker_service_id == null) throw new ApiException( _("Bayrell.CloudOS", "Service ID is not set"), -1 );
		
		/* Delete service */
		string url_api = "/services/" ~ docker_service_id;
		string content = await DockerLib::dockerApi(url_api, "DELETE");
		Dict res = rtl::json_decode(content);
		
		/* Success */
		if (content != "")
		{
			/* Check if error */
			string message = res.get("message", "");
			if (message != "")
			{
				throw new ApiException( message, -1 );
			}
			
			throw new ApiException( "Error disable service", -1 );
		}
		
		/* Disables service in database */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		Cursor cursor = await orm.query
		(
			"update services set enable=0 where docker_service_id = :docker_service_id limit 1",
			{
				"docker_service_id": docker_service_id,
			}
		);
		await cursor.close();
		
		Dict item = await this.getServiceFromDb(docker_service_id);
		
		return { "Message": _("Bayrell.CloudOS", "Service disabled"), "Code": 1, "item": item };
	}
	
	
	
	/**
	 * Returns item by service id from database
	 */
	async Dict getServiceFromDb(string docker_service_id)
	{
		string table_name = static::getTableName();
		
		/* Process primary key */
		Dict pk =
		{
			"docker_service_id": docker_service_id,
		};
		pk = this.toDatabase(pk);
		
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		/* Create query */
		Cursor cursor = await orm.select(table_name, pk, 0, 1);
		Dict item = cursor.fetchOne();
		await cursor.close();
		
		/* From database */
		item = await this.fromDatabase(item);
		
		return item;
	}
	
	
	
	/**
	 * Update service in database
	 */
	static async Dict updateServiceInDatabase(string old_service_id, Dict json)
	{
		/* Get ORM driver */
		ORMDriver orm = @.getDriver(classof ORMDriver);
		
		int time = rtl::time();
		string new_service_id = json["ID"] |> default string "";
		string service_name = json["Spec", "Name"] |> default string ""
		string service_image = json["Spec", "TaskTemplate", "ContainerSpec", "Image"] |> default string "";
		
		if (new_service_id == null) throw new ApiException( _("Bayrell.CloudOS", "New service id is not set"), -1 );
		
		/* Update service id */
		if (old_service_id != "")
		{
			Cursor cursor = await orm.query
			(
				"update services set docker_service_id=:new_service_id, is_deleted=0, enable=1 " ~
					" where docker_service_id = :old_service_id limit 1",
				{
					"old_service_id": old_service_id,
					"new_service_id": new_service_id,
				}
			);
			await cursor.close();
		}
		
		if (old_service_id != new_service_id)
		{
			/* Delete wrong service */
			if (old_service_id != "")
			{
				Cursor cursor = await orm.query
				(
					"delete from services " ~
						" where docker_service_id = :old_service_id limit 1",
					{
						"old_service_id": old_service_id,
					}
				);
				await cursor.close();
			}
		}
		
		/* Insert or update */
		await orm.insert_or_update
		(
			"services",
			{
				"docker_service_id": new_service_id,
			},
			{
				"_name": service_name,
				"_image": service_image,
				"is_deleted": 0,
				"enable": 1,
				"timestamp": time,
				"json": rtl::json_encode(json),
			}
		);
		
		return { "Message": _("Bayrell.CloudOS", "Service deleted"), "Code": 1 };
	}
	
}