/*!
 *  Bayrell Cloud Web Panel
 *
 *  (c) Copyright 2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace App;

use Runtime.lib;
use Runtime.RuntimeUtils;
use Runtime.Exceptions.RuntimeException;
use Runtime.ORM.Cursor;
use Runtime.ORM.ORMProviderInterface;


class DockerLib
{
	#ifdef BACKEND then
	
	/**
	 * Send docker command
	 */
	static async string dockerApi(string url, string m = "GET", string post = null)
	{
		string content = "";
		string cmd = "sudo /usr/bin/curl -s -X " ~ m ~ " -H 'Content-Type: application/json' ";
		if (post != null) cmd ~= "-d '" ~ post ~ "' ";
		
		cmd ~= "--unix-socket /var/run/docker.sock http:/v1.39" ~ url;
		
		#ifcode PHP then
		$content = @shell_exec($cmd . " &2>/dev/null");
		#endif
		
		return content;
	}
	
	
	
	/**
	 * Get diff from spec
	 */
	pure Dict getDockerUpdateSpec(Dict old_json, Dict new_json)
	{
		if (old_json === null) return null;
		if (new_json === null) return null;
		
		bool updated = false;
		Dict diff_spec = rtl::attr(old_json, ["Spec"], {});
		
		/* Change image */
		string old_image = rtl::attr(old_json, ["Spec", "TaskTemplate", "ContainerSpec", "Image"], "");
		string new_image = rtl::attr(new_json, ["Spec", "TaskTemplate", "ContainerSpec", "Image"], "");
		if (old_image != new_image and new_image != "")
		{
			if (rtl::attr(diff_spec, ["TaskTemplate"], null) === null)
			{
				diff_spec = rtl::setAttr(diff_spec, ["TaskTemplate"], {});
			}
			if (rtl::attr(diff_spec, ["TaskTemplate", "ContainerSpec"], null) === null)
			{
				diff_spec = rtl::setAttr(diff_spec, ["TaskTemplate", "ContainerSpec"], {});
			}
			diff_spec = rtl::setAttr(diff_spec, ["TaskTemplate", "ContainerSpec", "Image"], new_image);
			updated = true;
		}
		
		return [updated, diff_spec];
	}
	
	
	
	/**
	 * Get service from docker
	 */
	static async Dict dockerGetService(string service_id)
	{
		string url_api = "/services/" ~ service_id;
		string content = await static::dockerApi(url_api);
		return RuntimeUtils::json_decode(content);
	}
	
	
	
	/**
	 * Add service in docker
	 */
	static async Dict dockerAddService(Dict json)
	{
		string s = json -> attr "Spec" -> RuntimeUtils::json_encode;
		string url_api = "/services/create";
		string content = await static::dockerApi(url_api, "POST", s);
		Dict res = RuntimeUtils::json_decode(content);
		if (res == null) throw new RuntimeException( _("App", "Error create service in docker"), -1 );
		
		string message = res -> attr "message" -> monad lib::default( _("App", "Service does not created") );
		string service_id = res -> attr "ID";
		if (service_id == null) throw new RuntimeException( message, -1 );
		
		/* Update spec of the service */
		Dict new_json = await static::dockerGetService(service_id);
		await static::databaseUpdateService(service_id, new_json);
		
		return { "Message": _("App", "Service created"), "Code": 1, "json": new_json, "service_id": service_id };
	}
	
	
	
	/**
	 * Update service in docker
	 */
	static async Dict dockerUpdateService(Dict new_json)
	{
		string service_id = new_json -> attr "ID";
		if (service_id == null) throw new RuntimeException( _("App", "Service ID is not set"), -1 );
		
		Dict old_spec = static::dockerGetService(service_id);
		service_id = old_spec -> attr "ID";
		if (service_id == null) throw new RuntimeException( _("App", "Service in docker not found"), -1 );
		
		string version = old_spec -> attr "Version" -> attr "Index";
		if (version == null) throw new RuntimeException( _("App", "Service version is null"), -1 );
		
		list res = static::getDockerUpdateSpec(old_spec, new_json);
		if (res == null)  throw new RuntimeException( _("App", "Update docker service spec error"), -1 );
		
		bool updated = res[0];
		Dict diff_spec = res[1];
		if (not updated) return { "Message": _("App", "Service not updated"), "Code": 2 };
		
		string s = RuntimeUtils::json_encode(diff_spec);
		string url_api = "/services/" ~ service_id ~ "/update?version=" ~ version;
		
		/* Update service */
		string content = await static::dockerApi(url_api, "POST", s);
		Dict res = RuntimeUtils::json_decode(content);
		
		return { "Message": _("App", "Service updated"), "Code": 1 };
	}
	
	
	
	/**
	 * Enable service in docker
	 */
	static async Dict dockerEnableService(string old_service_id)
	{
		if (old_service_id == null) throw new RuntimeException( _("App", "Service ID is not set"), -1 );
		
		Dict item = await static::databaseGetServiceById(old_service_id);
		if (item == null) throw new RuntimeException( _("App", "Service in database not found"), -1 );
		
		Dict spec = item -> attr "json" -> RuntimeUtils::json_decode -> attr "Spec" -> RuntimeUtils::json_encode;
		if (spec == null) throw new RuntimeException( _("App", "Spec not found"), -1 );
		
		string url_api = "/services/create";
		string content = await static::dockerApi(url_api, "POST", spec);
		Dict res = RuntimeUtils::json_decode(content);
		if (res == null) throw new RuntimeException( _("App", "Create service error"), -1 );
		
		string new_service_id = res -> attr "ID";
		if (new_service_id == null) throw new RuntimeException( _("App", "Service does not created"), -1 );
		
		/* Update spec of the service */
		Dict spec = await static::dockerGetService(new_service_id);
		await static::databaseUpdateService(old_service_id, spec);
		
		return { "Message": _("App", "Service enabled"), "Code": 1, "service_id": new_service_id };
	}
	
	
	
	/**
	 * Delete service in docker
	 */
	static async Dict dockerDisableService(string service_id)
	{
		if (service_id == null) throw new RuntimeException( _("App", "Service ID is not set"), -1 );
		
		/* Delete service */
		string url_api = "/services/" ~ service_id;
		string content = await static::dockerApi(url_api, "DELETE");
		Dict res = RuntimeUtils::json_decode(content);
		
		/* Success */
		if (content != "")
		{
			/* Check if error */
			string message = res.get("message", "");
			if (message != "")
			{
				throw new RuntimeException( message, -1 );
			}
			
			throw new RuntimeException( "Error disable service", -1 );
		}
		
		/* Disables service in database */
		ORMProviderInterface p = @ -> method getProvider(classof ORMProviderInterface);
		p
			-> await method query
			(
				"update " ~ p.prefix ~ "docker_services set enable=0 where service_id = :service_id limit 1",
				{
					"service_id": service_id,
				}
			)
			-> await method end
		;
		
		return { "Message": _("App", "Service disabled"), "Code": 1 };
	}
	
	
	
	/**
	 * Update service from database
	 */
	static async Dict databaseUpdateService(string old_service_id, Dict json)
	{
		if (old_service_id == null) throw new RuntimeException( _("App", "Old service id is not set"), -1 );
		
		int time = @.time();
		string new_service_id = json.get("ID", "");
		string service_name = json -> lib::attr(["Spec", "Name"], "");
		string service_image = json -> lib::attr(["Spec", "TaskTemplate", "ContainerSpec", "Image"], "");
		
		if (new_service_id == null) throw new RuntimeException( _("App", "New service id is not set"), -1 );
		
		/* Update service id */
		ORMProviderInterface p = @ -> method getProvider(classof ORMProviderInterface);
		p
			-> await method query
			(
				"update " ~ p.prefix ~ "docker_services set service_id=:new_service_id, is_deleted=0, enable=1 " ~
					" where service_id = :old_service_id limit 1",
				{
					"old_service_id": old_service_id,
					"new_service_id": new_service_id,
				}
			)
			-> await method end
		;
		
		/* Delete wrong service */
		p
			-> await method query
			(
				"delete from " ~ p.prefix ~ "docker_services " ~
					" where service_id = :old_service_id limit 1",
				{
					"old_service_id": old_service_id,
				}
			)
			-> await method end
		;
		
		/* Insert or update */
		p
			-> await method insert_or_update
			(
				p.prefix ~ "docker_services",
				{
					"service_id": new_service_id,
				},
				{
					"_name": service_name,
					"_image": service_image,
					"is_deleted": 0,
					"enable": 1,
					"timestamp": time,
					"json": RuntimeUtils::json_encode(json),
				}
			)
			-> await method end
		;
		
		return { "Message": _("App", "Service deleted"), "Code": 1 };
	}
	
	
	
	/**
	 * Delete service from database
	 */
	static async Dict databaseDeleteService(string service_id)
	{
		if (service_id == null) throw new RuntimeException( _("App", "Service ID is not set"), -1 );
		
		/* Delete service from database */
		ORMProviderInterface p = @ -> method getProvider(classof ORMProviderInterface);
		p
			-> await method query
			(
				"update " ~ p.prefix ~ "docker_services set is_deleted=1 where service_id = :service_id limit 1",
				{
					"service_id": service_id,
				}
			)
			-> await method end
		;
		
		return { "Message": _("App", "Service deleted"), "Code": 1 };
	}
	
	
	
	/**
	 * Returns service by id
	 */
	static async Dict databaseGetServiceById(string service_id)
	{
		if (service_id == "") return null;
		ORMProviderInterface p = @ -> method getProvider(classof ORMProviderInterface);
		Dict item = p
			-> await method query
			(
				"select * from " ~ p.prefix ~ "docker_services where service_id = :service_id limit 1",
				{
					"service_id": service_id,
				}
			)
			-> await method getOne
		;
		return item;
	}
	
	#endif
}