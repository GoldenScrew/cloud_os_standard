/*!
 *  Bayrell Cloud Web Panel
 *
 *  (c) Copyright 2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace App;

use Runtime.Context;
use Runtime.CoreStruct;
use Runtime.RuntimeConstant;
use Runtime.Annotations.Entity;
use Runtime.Annotations.Manager;
use Runtime.Annotations.LambdaChain;
use Runtime.Annotations.LambdaChainDeclare;
use Runtime.Annotations.Provider;
use Runtime.Interfaces.AssetsInterface;
use Runtime.Interfaces.ContextInterface;
use Runtime.Interfaces.ModuleDescriptionInterface;
use Runtime.Web.Annotations.Route;
use Runtime.Web.RenderContainer;
use Runtime.Web.RenderHelper;
use Runtime.Web.Request;


class ModuleDescription implements 
	ModuleDescriptionInterface,
	AssetsInterface
{

	
	/**
	 * Returns module name
	 * @return string
	 */
	pure string getModuleName() => "App";
	
	
	
	/**
	 * Returns module name
	 * @return string
	 */
	pure string getModuleVersion() => "0.9.0";
	
	
	
	/**
	 * Returns required modules
	 * @return Dict<string>
	 */
	pure Dict<string> requiredModules() =>
	{
		'Runtime': '>=0.3',
		'Runtime.Web': '*',
		'Runtime.Web.CRUD': '*',
		
		/* Backend */
		#ifdef BACKEND then
		'Runtime.ORM.MySQL': '*',
		'Runtime.Task': '*',
		'Runtime.Web.Backend': '*',
		#endif
	};
	
	
	
	/**
	 * Returns module files load order
	 * @return Collection<string>
	 */
	pure Collection<string> assets() => 
	[
		"App/AdminerPage",
		"App/IndexPage",
		"App/AdminLayout",
		"App/Nginx/NginxPage",
		"App/Nginx/NginxPageModel",
		"App/Service/ServiceForm",
		"App/Service/ServicePage",
		"App/Service/ServicePageModel",
		"App/User/AuthPage",
		"App/User/AuthToken",
		"App/User/UserPage",
		"App/User/UserPageModel",
		"App/Yaml/YamlForm",
		"App/Yaml/YamlPage",
		"App/Yaml/YamlPageModel",
		"App/Yaml/YamlFilesPage",
		"App/Yaml/YamlFilesPageModel",
		"App/ModuleDescription",
	];
	
	
	
	/**
	 * Returns enities
	 */
	pure Collection<Dict> entities() =>
	[
		/* Pages */
		new Entity{ "name": "App.IndexPage" },
		new Entity{ "name": "App.Nginx.NginxPage" },
		new Entity{ "name": "App.Service.ServicePage" },
		new Entity{ "name": "App.User.AuthPage" },
		new Entity{ "name": "App.User.UserPage" },
		new Entity{ "name": "App.Yaml.YamlPage" },
		new Entity{ "name": "App.Yaml.YamlFilesPage" },
		
		/* Layout */
		new LambdaChain
		{
			"name": RenderHelper::LAYOUT_CHAIN,
			"value": "App.ModuleDescription::layout",
		},
		
		
		/* Backend */
		#ifdef BACKEND then
		
		new Entity{ "name": "App.AdminerPage" },
		new Entity{ "name": "App.SyncDockerServicesTask" },
		
		new LambdaChain
		{
			"name": RenderHelper::RENDER_CHAIN,
			"value": "App.User.AuthToken::RenderChainMiddleware",
			"pos": RenderHelper::RENDER_CHAIN_MIDDLEWARE,
		},
		
		new Entity{ "name": "App.Nginx.NginxCrudApi" },
		new Entity{ "name": "App.Service.ServiceCrudApi" },
		new Entity{ "name": "App.User.AuthApi" },
		new Entity{ "name": "App.User.UserCrudApi" },
		new Entity{ "name": "App.Yaml.YamlCrudApi" },
		new Entity{ "name": "App.Yaml.YamlFilesCrudApi" },
		#endif
		
		
		/* Frontend */
		#ifdef FRONTEND then
		new Provider
		{
			"name": RenderHelper::BUS_INTERFACE,
			"value": "Runtime.Web.Drivers.BusProvider",
		}
		#endif
	];
	
	
	
	/**
	 * Returns sync loaded files
	 */		
	pure Vector<string> resources() =>
	[
		"@App/core.css",
	];
	
	
	
	/**
	 * App layout
	 */
	pure string layout(RenderContainer container)
	{
		string layout_name = container["layout"]["layout_name"];
		if (layout_name == "admin") return "App.AdminLayout";
		return "Runtime.Web.Layout";
	}
	
	
	#ifdef BACKEND then
	
	/**
	 * Returns context settings
	 * @return Dict<string>
	 */
	pure Dict<string> appSettings(Dict env) => 
	{
		"config":
		{
			"App.User.AuthToken":
			{
				"EXPIRE": env.get("COOKIE_EXPIRE", 100800),
				"COOKIE_NAME": env.get("COOKIE_NAME", "jwt_token"),
				"AUTH_PUBLIC_KEY": env.get("AUTH_PUBLIC_KEY", ""),
				"AUTH_PRIVATE_KEY": env.get("AUTH_PRIVATE_KEY", ""),
			},
			"Runtime.Web.Backend":
			{
				"api": true,
				"bus_default": true,
				"bus": "",
			},
		},
		"secrets":
		{
		},
		"providers":
		{
			"Runtime.ORM.MySQL.Provider":
			{
				"default":
				{
					"host": env.get("MYSQL_HOST", ""),
					"username": env.get("MYSQL_USERNAME", ""),
					"password": env.get("MYSQL_PASSWORD", ""),
					"db": env.get("MYSQL_DB", ""),
				}
			}
		}
	};
	
	
	
	/**
	 * Init context
	 */
	static Context appInit(Context c)
	{
		return c -> method init;
	}
	
	
	
	/**
	 * Start context
	 */
	static async Context appStart(Context c)
	{
		return c -> await method start;
	}
	
	
	
	/**
	 * Run request
	 */
	static async RenderContainer appRequest(Context c, Request request)
	{
		Route route = null;
		Dict<string> params = null;
		Collection<Route> routes = RenderHelper::getRoutesByEntities(c.entities);
		
		/* Search route */
		list res = RenderHelper::findRoute(routes, request);
		route = res.item(0); params = res.item(1);
		
		/* Create render container  */
		RenderContainer container = new RenderContainer
		{
			"request": request,
			"route": route,
			"route_params": params,
		};
		
		/* Render route */
		container = c -> await method chainAwait(RenderHelper::RENDER_CHAIN, [ container ]);
		
		/* Result */
		return container;
	}
	
	#endif
}
