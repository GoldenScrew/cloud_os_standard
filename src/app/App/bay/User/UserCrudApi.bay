/*!
 *  Bayrell Cloud Web Panel
 *
 *  (c) Copyright 2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace App.User;

use Runtime.lib;
use Runtime.MessageRPC;
use Runtime.Monad;
use Runtime.RuntimeUtils;
use Runtime.Exceptions.ApiException;
use Runtime.Exceptions.RuntimeException;
use Runtime.Crypt.Password;
use Runtime.ORM.Cursor;
use Runtime.ORM.ORMProviderInterface;
use Runtime.Web.Annotations.ApiList;
use Runtime.Web.Annotations.ApiMethod;
use Runtime.Web.Annotations.Route;
use Runtime.Web.Annotations.RouteList;
use Runtime.Web.CRUD.CrudApi;
use Runtime.Web.CRUD.CrudInterface;
use Runtime.Web.CRUD.FieldInfo;
use Runtime.Web.Cookie;
use Runtime.Web.JsonResponse;
use Runtime.Web.RenderContainer;
use Runtime.Web.Response;
use App.User.UserPageModel;


@ApiList{ "api_name": "App.User", "space_name": classof CrudInterface }
class UserCrudApi extends CrudApi implements CrudInterface
{
	
	#ifdef BACKEND then
	
	
	/**
	 * Returns crud model name
	 */
	pure string crudModelName() => classof UserPageModel;
	
	
	
	/**
	 * Returns crud table name
	 */
	pure string crudTableName() => "docker_users";
	
	
	
	/**
	 * Api init
	 */
	pure async CrudApi apiInit(CrudApi api) => api;
	
	
	
	/**
	 * Convert item from database
	 */
	pure fn<Dict, Dict> fromDatabase(CrudApi api) =>
		Dict (Dict item) => item
	;
	
	
	
	/**
	 * Convert item to database
	 */
	pure fn<Dict, Dict> toDatabase(CrudApi api) =>
		Dict (Dict item) => item
	;
	
	
	
	/**
	 * Validate item
	 */
	static Dict<Collection<string>> validateItem
		(CrudApi api, Dict<FieldInfo> fields, Dict item, Dict<Collection<string>> validate)
	{
		string password1 = item["password1"];
		string password2 = item["password2"];
		
		if (password1 != "" and password1 != password2)
		{
			validate = validate
				-> static::addValidateError("password2", _("App", "Password must be equal"))
			;
		}
		
		return validate;
	}
	
	
	
	/**
	 * Process item
	 */
	pure fn<var, Dict> processItem(CrudApi api, Dict filter_item, Dict new_item, Dict old_item = null)
		=> filter_item
	;
	
	
	
	/**
	 * Search
	 */
	@ApiMethod{ "method_name": "search" }
	static async MessageRPC search(MessageRPC msg)
	{
		return await parent::search(msg);
	}
	
	
	
	/**
	 * Get by ID
	 */
	@ApiMethod{ "method_name": "findItem" }
	static async MessageRPC findItem(MessageRPC msg)
	{
		return await parent::findItem(msg);
	}
	
	
	
	/**
	 * Create
	 */
	@ApiMethod{ "method_name": "create" }
	static async MessageRPC create(MessageRPC msg)
	{
		Dict item = msg["data"]["item"];
		msg = await parent::create(msg);
		
		/* Save password if exists */
		string user_id = msg["response"]["item"]["id"];
		await static::savePassword(user_id, item);
		
		/* Generate nginx password */
		await static::nginxPasswdCreate();
		
		return msg;
	}
	
	
	
	/**
	 * Update
	 */
	@ApiMethod{ "method_name": "update" }
	static async MessageRPC update(MessageRPC msg)
	{
		Dict item = msg["data"]["item"];
		msg = await parent::update(msg);
		
		/* Save password if exists */
		string user_id = msg["response"]["item"]["id"];
		await static::savePassword(user_id, item);
		
		/* Generate nginx password */
		await static::nginxPasswdCreate();
		
		return msg;
	}
	
	
	
	/**
	 * Delete
	 */
	@ApiMethod{ "method_name": "delete" }
	static async MessageRPC delete(MessageRPC msg)
	{
		return await parent::delete(msg);
	}
	
	
	
	/**
	 * Save password
	 */
	static async void savePassword(string user_id, Dict item)
	{
		string password1 = item["password1"];
		string password2 = item["password2"];
		
		if (password1 != "")
		{
			ORMProviderInterface p = @ -> method getProvider(classof ORMProviderInterface);
			
			p
			/* -> lib::set("log_query", true) */
			-> await method insert_or_update
			(
				p.prefix ~ "docker_users_auth",
				{
					"user_id": user_id,
					"type": "password",
				},
				{
					"value": Password::createHash(password1),
				}
			)
			-> await method end;
			
		}
	}
	
	
	
	/**
	 * Nginx password
	 */
	static async void nginxPasswdCreate()
	{
		string htpasswd = "";
		ORMProviderInterface p = @ -> method getProvider(classof ORMProviderInterface);
		string table_name = static::crudTableName();
		
		Cursor cursor = p -> await method query
		(
			"select u.*, a.value as password from " ~ p.prefix ~ "docker_users as u " ~
			"left join docker_users_auth as a on (u.id = a.user_id and a.type='password')",
		);
		
		while (true)
		{
			Dict row = await cursor.fetch();
			if (row == null)
			{
				break;
			}
			
			int banned = row["banned"];
			string name = row["name"];
			string password = row["password"];
			
			htpasswd ~= name ~ ":" ~ password ~ "\n";
		}
		
		await cursor.close();
		
		
		/* Insert or update nginx file */
		p
			-> await method insert_or_update
			(
				p.prefix ~ "docker_nginx",
				{
					"name": "inc/htpasswd.inc",
				},
				{
					"enable": 1,
					"content": htpasswd,
					"timestamp": @.time(),
					"is_deleted": 0,
				}
			)
			-> await method end;
	}
	
	#endif
	
}
