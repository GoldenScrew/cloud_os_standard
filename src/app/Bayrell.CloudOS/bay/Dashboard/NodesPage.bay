/*!
 *  Bayrell Cloud OS
 *
 *  (c) Copyright 2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace App.Dashboard;

use Runtime.lib;
use Runtime.MessageRPC;
use Runtime.Web.Annotations.Route;
use Runtime.Web.Annotations.RouteList;
use Runtime.Web.Annotations.RouteMiddleware;
use Runtime.Web.Events.MouseClickEvent;
use Runtime.Web.Frontend.Component;
use Runtime.Web.Frontend.LayoutModel;
use Runtime.Web.RenderContainer;
use Runtime.Web.RenderHelper;
use Runtime.Web.Response;
use App.Dashboard.NodesPageModel;


@RouteList{}
@RouteMiddleware{ "value": "App.User.AuthToken::checkAuthRouteMiddleware" }
class NodesPage extends Component
{
	
	/**
	 * Returns module name
	 */
	pure string moduleName() => "App";
	
	
	
	/**
	 * Route Action
	 * @return WebContainer
	 */
	@Route{ "uri": "/nodes/", "name": "app.dashboard.nodes" }
	static async RenderContainer actionIndex(RenderContainer container)
	{
		/* Set title */
		container <= layout <= title <= "Nodes";
		container <= layout <= layout_name <= "admin";
		
		/* Get services state */
		MessageRPC msg = container -> await method sendMessage
		{
			"api_name": "App.Dashboard",
			"space_name": "default",
			"method_name": "status",
			"data":
			{
			},
		};
		
		/* Create model */
		container <= layout <= page_class <= classof NodesPage;
		container <= layout <= page_model <= new NodesPageModel
		{
			"services": (msg -> method isSuccess) ? msg["response"]["services"] : null,
			"nodes": (msg -> method isSuccess) ? msg["response"]["nodes"] : null,
		};
		
		return container;
	}
	
	
	
	/**
	 * Component css
	 */
	pure string css(Dict<string> vars) => 
		@css{
			
		}
	;
	
	
	
	/**
	 * Component render
	 */
	pure html render(LayoutModel layout, NodesPageModel model, Dict params, html content)
	{
		if (model.nodes == null) return "";
		
		return
			<div @class="nodes">
			{
				model.nodes.map
				(
					html (Dict node, int index) use (model) =>
						<div @class="node" @key={ index }>
							<div @class="node_name">{ _("App", "Hostname") }: { node["Description"]["Hostname"] }</div>
							<ul @class="node_services">
								{ static::renderNodeTasks(model, node) }
							</ul>
						</div>
				)
			}
			</div>
		;
	}
	
	
	
	/**
	 * Render tasks
	 */
	pure html renderNodeTasks(NodesPageModel model, Dict node)
	{
		Collection tasks = static::getNodeTasks(model, node);
		return tasks.map
		(
			html (Dict task) =>
				<li @class="node_service">
					{ task["ServiceName"] } [{ task["ID"] }] { _("App", "Address") }:&nbsp;
					{
						rs::join
						(
							", ",
							task["Networks"].map
							(
								string (Dict net) => net["Addresses"][0]
							)
						)
					}
				</li>
		);
	}
	
	
	
	/**
	 * Get node tasks
	 */
	pure html getNodeTasks(NodesPageModel model, Dict node)
	{
		Vector tasks = new Vector();
		
		if (model.services != null)
		{
			for (int i=0; i<model.services.count(); i++)
			{
				Dict item = model.services.item(i);
				Collection Tasks = item["balancer"]["Tasks"];
				for (int j=0; j<Tasks.count(); j++)
				{
					Dict task = Tasks.item(j);
					if (task["Node"]["ID"] == node["ID"] and task["Status"]["State"] == "running")
					{
						tasks.push(task.setIm("ServiceName", item["_name"]));
					}
				}
			}
		}
		
		return tasks.toCollection();
	}
	
	
	#ifdef FRONTEND then
	
	/**
	 * On click
	 */
	public void onClick(MouseClickEvent e)
	{
		int pos = e.target.params["data-index"];
		this.updateModel
		{
			"active": pos,
		};
	}
	
	#endif
	
}